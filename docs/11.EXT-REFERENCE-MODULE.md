#  Modules API

## jerryx_module_resolve

**Summary**

Load a copy of a module into the current context or return one that was already loaded if it is found.

**Prototype**

```c
jerry_value_t
jerryx_module_resolve (const jerry_char_t *name);
```

- `name` - the name of the module to load.
- return value - `jerry_value_t` representing the module that was loaded, or the error that occurred in the process.


# Modules data types

## jerryx_module_t

**Summary**

Structure to define a module

**Prototype**

```c
typedef struct
{
  jerry_char_t *name; /**< name of the module */
  jerry_value_t (*on_resolve)(void); /**< function that returns a new instance of the module */
} jerryx_module_t;
```

# Modules helper macros

## JERRYX_MODULE

**Summary**

Helper macro to define a module. Declares a variable of type `jerryx_module_t` as global static and places it into the
appropriate linker section of the executable.

**Note**: The helper macro must appear at the bottom of a source file, and no semicolon must follow it.

**Prototype**
```c
#define JERRYX_MODULE(module_name, on_resolve_cb)
```

- `module_name` - the name of the module without quotes
- `on_resolve_cb` - the function that will be called when the module needs to be loaded.

**Example**

```c
#include "jerryscript.h"
#include "jerryscript-ext/module.h"

static jerry_value_t
my_module_on_resolve (void)
{
  return jerry_create_external_function (very_useful_function);
} /* my_module_on_resolve */

/* Note that there is no semicolon at the end of the next line. This is how it must be. */
JERRYX_MODULE (my_module, my_module_on_resolve)
```

**See also**

- [jerryx_module_t](#jerryx_module_t)


## JERRYX_MODULE_RESOLVER

**Summary**

Define a module resolver. An invocation of this macro is to be followed by the body of a module resolver. The macro
declares a function of the name given in `cb_name` which accepts a single parameter `const jerry_char_t *name`. It is
expected that the function returns a non-zero value of type `jerry_value_t` if the resolver is able to associate `name`
with such a value, or zero if it is not. If the function returns non-zero, it is expected to cache the result so that if
called again with the same `name`, it will return the same result.

**Prototype**

```c
JERRYX_MODULE_RESOLVER(cb_name)
```

- `cb_name` - the name of the module resolver function to declare.

**Example**

```c
#include <string.h>
#include "jerryscript.h"
#include "jerryscript-ext/module.h"

JERRYX_MODULE_RESOLVER (my_resolver)
{
  jerry_value_t ret = 0;

  /* This example resolver only knows how to resolve one name: "my_special_module" */
  if (!strcmp (name, "my_special_module"))
  {
    /*
     * This attempts to retrieve the jerry_value_t that was computed for "my_special_module" during a previous call to
     * this resolver.
     */
    ret = my_special_module_get_cached ();

    /* "my_special_module" has never been loaded in this context before */
    if (ret == 0)
    {
      /* Do the heavy lifting of loading the module for the first time */
      ret = my_special_module_load_for_the_first_time ();

      /*
       * Add the module to a cache that will cause my_special_module_get_cached () to return the value of ret on
       * subsequent calls to this resolver, removing the need to call my_special_module_load_for_the_first_time () in
       * the future.
       */
      my_special_module_cache (ret);
    }
  }

  return ret;
}
```
